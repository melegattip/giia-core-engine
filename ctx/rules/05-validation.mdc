---
alwaysApply: true
---

# üö® Reglas de Validaci√≥n

## Input Validation

### Validaciones Obligatorias
- **Par√°metros nulos**: Verificar que no sean nil/null
- **Rangos num√©ricos**: Validar que est√©n dentro de rangos esperados
- **Longitud de strings**: Verificar l√≠mites m√°ximos/m√≠nimos
- **Formatos**: Validar emails, fechas, IDs, etc.

### Ejemplos de Validaci√≥n
```go
// ‚úÖ Validaci√≥n de par√°metros de entrada
func ValidateSearchRequest(userID int64, products []string) error {
    if userID <= 0 {
        return errors.NewBadRequest("userID must be positive")
    }
    
    if len(products) > 10 {
        return errors.NewBadRequest("too many products specified")
    }
    
    for _, product := range products {
        if len(product) == 0 {
            return errors.NewBadRequest("product name cannot be empty")
        }
    }
    
    return nil
}

// ‚úÖ Validaci√≥n en funciones
func (r *Repository) Search(ctx context.Context, userID int64, products []string) ([]entities.SearchResults, error) {
    // Validaci√≥n temprana
    if err := ValidateSearchRequest(userID, products); err != nil {
        return nil, err // Error ya tipado, no necesita wrapping
    }
    
    // L√≥gica principal...
}
```

## Security Validations

### Sanitizaci√≥n de Datos
```go
// ‚úÖ Limpiar inputs antes de procesarlos
func SanitizeUserInput(input string) string {
    // Remover caracteres peligrosos
    cleaned := strings.TrimSpace(input)
    cleaned = strings.ReplaceAll(cleaned, "<", "")
    cleaned = strings.ReplaceAll(cleaned, ">", "")
    return cleaned
}

// ‚úÖ Validar formato de IDs
func ValidateUserID(userID string) error {
    if _, err := strconv.ParseInt(userID, 10, 64); err != nil {
        return errors.NewBadRequest("invalid user ID format")
    }
    return nil
}
```

### Authentication & Authorization
```go
// ‚úÖ Validar headers de autenticaci√≥n
func ValidateAuthHeaders(headers map[string]string) error {
    callerID, exists := headers["X-Caller-Id"]
    if !exists || callerID == "" {
        return errors.NewBadRequest("X-Caller-Id header is required")
    }
    
    if _, err := strconv.ParseInt(callerID, 10, 64); err != nil {
        return errors.NewBadRequest("invalid X-Caller-Id format")
    }
    
    return nil
}
```

## Business Logic Validation

### Validaciones de Dominio
```go
// ‚úÖ Validar reglas de negocio
func ValidateCreditLineRequest(req *CreditLineRequest) error {
    if req.UserID <= 0 {
        return errors.NewBadRequest("invalid user ID")
    }
    
    // Validar productos disponibles
    validProducts := map[string]bool{
        "consumer_loan": true,
        "personal_loan": true,
        "short_loan":    true,
    }
    
    for _, product := range req.Products {
        if !validProducts[product] {
            return errors.NewBadRequest("invalid product: " + product)
        }
    }
    
    return nil
}
```

### Estados y Transiciones
```go
// ‚úÖ Validar transiciones de estado
func ValidateStatusTransition(from, to string) error {
    validTransitions := map[string][]string{
        "pending":  {"approved", "rejected"},
        "approved": {"paused", "cancelled"},
        "paused":   {"approved", "cancelled"},
    }
    
    validToStates, exists := validTransitions[from]
    if !exists {
        return errors.NewBadRequest("invalid from status: " + from)
    }
    
    for _, validTo := range validToStates {
        if validTo == to {
            return nil
        }
    }
    
    return errors.NewBadRequest("invalid transition from " + from + " to " + to)
}
```

## Error Handling

### Tipos de Errores Disponibles
```go
// ‚úÖ Errores de cliente (4xx)
errors.NewBadRequest("mensaje")           // 400 - Input inv√°lido
errors.NewUnauthorizedRequest("mensaje")  // 401 - Sin autenticaci√≥n  
errors.NewResourceNotFound("mensaje")     // 404 - Recurso no encontrado

// ‚úÖ Errores de servidor (5xx)
errors.NewInternalServerError("mensaje")  // 500 - Error interno
errors.NewTooManyRequests("mensaje")      // 429 - Rate limit excedido

// ‚úÖ Errores espec√≠ficos del dominio
errors.NewResourceParsingError("mensaje") // Error parseando datos
errors.NewSkippableError("mensaje")       // Error que puede ser ignorado
```

### Ejemplos de Uso por Contexto
```go
// ‚úÖ Funciones de error espec√≠ficas por tipo de validaci√≥n
func NewInvalidUserIDError() error {
    return errors.NewBadRequest("invalid user ID")
}

func NewInvalidProductError() error {
    return errors.NewBadRequest("invalid product")
}

func NewTooManyProductsError() error {
    return errors.NewBadRequest("too many products")
}

func NewMissingAuthHeaderError() error {
    return errors.NewBadRequest("missing authentication header")
}

// ‚úÖ Manejo de errores sin wrapping gen√©rico
func ValidateAndProcess(req *Request) error {
    if err := ValidateRequest(req); err != nil {
        return err // Error ya tipado, no necesita wrapping
    }
    
    if err := ProcessRequest(req); err != nil {
        return errors.NewInternalServerError("failed to process request")
    }
    
    return nil
}
```

## API Response Validation

### Validar Responses Externas
```go
// ‚úÖ Validar respuestas de APIs externas
func ValidateAPIResponse(response *APIResponse) error {
    if response == nil {
        return errors.NewBadRequest("response cannot be nil")
    }
    
    if response.StatusCode < 200 || response.StatusCode >= 300 {
        return errors.NewInternalServerError("API error: status " + strconv.Itoa(response.StatusCode))
    }
    
    if len(response.Data) == 0 {
        return errors.NewResourceNotFound("empty response data")
    }
    
    return nil
}
```

### Validar Formato de Datos
```go
// ‚úÖ Validar estructura de datos
func ValidateSearchResults(results []entities.SearchResults) error {
    if len(results) == 0 {
        return nil // Empty results are valid
    }
    
    for i, result := range results {
        if result.ID <= 0 {
            return errors.NewResourceParsingError("invalid ID in result " + strconv.Itoa(i))
        }
        
        if result.DateApproved.IsZero() {
            return errors.NewResourceParsingError("missing date_approved in result " + strconv.Itoa(i))
        }
        
        if len(result.AvailableProducts) == 0 {
            return errors.NewResourceParsingError("missing available_products in result " + strconv.Itoa(i))
        }
    }
    
    return nil
}
```

## Logging de Validaciones

### Log de Errores de Validaci√≥n
```go
// ‚úÖ Log structured para validaciones
func LogValidationError(ctx context.Context, err error, operation string, userID int64) {
    logger.Error(ctx, err, "Validation failed", logs.Tags{
        "operation": operation,
        "user_id":   userID,
        "error_type": "validation",
    })
}

// ‚úÖ Uso en funciones
func (s *Service) ProcessRequest(ctx context.Context, req *Request) error {
    if err := ValidateRequest(req); err != nil {
        LogValidationError(ctx, err, "process_request", req.UserID)
        return err // Error ya tipado, no necesita wrapping
    }
    
    // Continuar procesamiento...
}
```

## Checklist de Validaci√≥n

- [ ] ¬øSe validan todos los par√°metros de entrada?
- [ ] ¬øSe manejan casos de inputs nulos/vac√≠os?
- [ ] ¬øSe verifican rangos num√©ricos apropiados?
- [ ] ¬øSe validan headers de autenticaci√≥n?
- [ ] ¬øSe sanitizan inputs antes de procesarlos?
- [ ] ¬øSe validan reglas de negocio espec√≠ficas?
- [ ] ¬øSe logean errores de validaci√≥n apropiadamente?
- [ ] ¬øSe usan constructores de errores tipados ?
- [ ] ¬øSe retornan errores descriptivos y tipados al cliente?
