---
alwaysApply: true
---

# üß™ Reglas de Testing

## Comandos de Testing

### Con Fury (Preferido)
```bash
# Activar entorno
colima start

# Ejecutar tests
fury test
```

### Con Go Nativo
```bash
# Tests b√°sicos
go test ./... -count=1

# Tests con race detection
go test ./... -count=1 -race
```

### Coverage
```bash
# Generar coverage de un package espec√≠fico
go test -coverprofile=coverage.out [package_path]

# Ejemplo
go test -coverprofile=coverage.out github.com/melisource/fury_credits-scoring-engine/internal/core/usecases/subcases/information

# Visualizar coverage
go tool cover -html="coverage.out"
```

## Convenciones de Testing

### Estructura de Tests
Usar el patr√≥n **Given-When-Then**:

```go
// ‚úÖ Estructura recomendada
func TestFunctionName_Scenario_ExpectedBehavior(t *testing.T) {
    // Given - Preparar datos de prueba
    input := setupTestData()
    expectedResult := "expected_value"
    
    // When - Ejecutar funci√≥n bajo prueba
    result, err := FunctionToTest(input)
    
    // Then - Verificar resultados
    assert.NoError(t, err)
    assert.Equal(t, expectedResult, result)
}
```

### Convenciones de Nombrado de Variables en Test Cases

Para estructuras de casos de prueba, usar prefijos espec√≠ficos para identificar claramente el prop√≥sito de cada variable:

#### Prefijo `given` - Datos de Entrada y Configuraci√≥n
Variables que **nosotros establecemos** como datos de entrada, configuraci√≥n de mocks, o condiciones iniciales:

```go
// ‚úÖ Ejemplos de variables "given"
type testScenario struct {
    name                        string
    givenRequestString          string                    // Datos de entrada
    givenSiteID                 constants.Site           // Par√°metros de configuraci√≥n
    givenLatestRecord           *dependencies.DebtContext // Estados iniciales
    givenKvsGetError            error                     // Errores simulados en mocks
    givenKvsSaveError           error                     // Comportamiento de dependencias
    givenTimestampToUTCResponse time.Time               // Respuestas mockeadas
}
```

#### Prefijo `expected` - Resultados Esperados
Variables que representan **los resultados que esperamos** obtener del test:

```go
// ‚úÖ Ejemplos de variables "expected"  
type testScenario struct {
    expectedError               error  // Error esperado como resultado
    expectedKvsSaveCalls        int    // N√∫mero de llamadas esperadas
    expectedKvsGetCalls         int    // Interacciones esperadas con mocks
    expectedPublishCalls        int    // Validaciones de comportamiento
    expectedResult              string // Valores de retorno esperados
}
```

#### Ejemplo Completo
```go
type testScenario struct {
    name                        string
    // Given - Lo que establecemos
    givenUserID                 int64
    givenRequestData            string
    givenRepositoryError        error
    givenMockResponse           *entities.User
    
    // Expected - Lo que esperamos
    expectedError               error
    expectedResult              *entities.User
    expectedRepositoryCalls     int
    expectedCacheWrites         int
}
```

#### ‚ö†Ô∏è Beneficios de esta Convenci√≥n
- **Claridad**: Inmediatamente se identifica si una variable es entrada o resultado esperado
- **Mantenibilidad**: Facilita la lectura y modificaci√≥n de tests complejos
- **Consistencia**: Patr√≥n uniforme en todo el codebase para estructuras de test cases

### Naming Convention
```go
// Formato: TestFunctionName_Scenario_ExpectedBehavior
func TestSearch_WithValidUserID_ReturnsResults(t *testing.T) {}
func TestSearch_WithInvalidUserID_ReturnsError(t *testing.T) {}
func TestSearch_WithEmptyProducts_ReturnsAllProducts(t *testing.T) {}
```

## Convenciones de Mocks

### Ubicaci√≥n y Nomenclatura
- **Ubicaci√≥n**: Mismo package que lo que mockea
- **Nombre**: Igual al original + sufijo `Mock`
- **Archivo**: Termina en `_mock.go`

```go
// ‚úÖ Ejemplo: internal/core/providers/credit_line_mock.go
type CreditLineMock struct {
    mock.Mock
}

func (m *CreditLineMock) Search(ctx context.Context, userID int64, statuses []string, products []string) ([]entities.SearchResults, error) {
    args := m.Called(ctx, userID, statuses, products)
    return args.Get(0).([]entities.SearchResults), args.Error(1)
}
```

### Configuraci√≥n de Mocks
```go
// ‚úÖ Setup en tests - SER ESPEC√çFICO en los par√°metros
func TestService_ProcessData_Success(t *testing.T) {
    // Given
    mockRepo := new(CreditLineMock)
    service := NewService(mockRepo)
    
    expectedResults := []entities.SearchResults{{ID: 1}}
    expectedStatuses := []string{"approved", "active"}
    expectedProducts := []string{"consumer_loan", "personal_loan"}
    
    // ‚úÖ Especificar valores exactos en lugar de mock.Anything
    mockRepo.On("Search", 
        context.Background(),
        int64(123),
        expectedStatuses,
        expectedProducts,
    ).Return(expectedResults, nil)
    
    // When
    results, err := service.ProcessData(context.Background(), 123)
    
    // Then
    assert.NoError(t, err)
    assert.Equal(t, expectedResults, results)
    mockRepo.AssertExpectations(t)
}
```

### ‚ö†Ô∏è Reglas para mock.Anything
```go
// ‚ùå MAL - Usar mock.Anything indiscriminadamente
mockRepo.On("Search", mock.Anything, mock.Anything, mock.Anything, mock.Anything)

// ‚úÖ BIEN - Solo cuando realmente no importa el valor espec√≠fico
mockRepo.On("Search", 
    mock.AnythingOfType("*context.Context"), // Cuando el contexto no es relevante para el test
    int64(123),                              // UserID espec√≠fico
    []string{"approved"},                    // Statuses espec√≠ficos
    mock.Anything,                          // Solo si products realmente puede ser cualquier cosa
)

// üéØ MEJOR - Ser espec√≠fico siempre que sea posible
mockRepo.On("Search",
    context.Background(),
    int64(123),
    []string{"approved", "active"},
    []string{"consumer_loan"},
).Return(expectedResults, nil)
```

### üéØ Best Practices para Mocks

#### Principios Fundamentales
- **Ser espec√≠fico** es mejor que usar `mock.Anything`
- **Validar comportamiento** no solo resultados
- **Un mock por responsabilidad** - no mockear todo
- **Limpiar mocks** entre tests

#### Cu√°ndo usar mock.Anything
```go
// ‚úÖ ACEPTABLE - Context que no afecta la l√≥gica de negocio
mockService.On("ProcessData", mock.AnythingOfType("*context.Context"), specificUserID)

// ‚úÖ ACEPTABLE - IDs generados din√°micamente que no se pueden predecir
mockRepo.On("Save", mock.AnythingOfType("*entities.User")).Return(mock.Anything, nil)

// ‚ùå EVITAR - Par√°metros que s√≠ importan para la l√≥gica
mockRepo.On("FindByStatus", mock.Anything) // ¬øQu√© status? ¬°Debe ser espec√≠fico!
```

#### Validaciones en Mocks
```go
// ‚úÖ Validar que se llam√≥ con par√°metros correctos
mockRepo.On("UpdateStatus", int64(123), "approved").Return(nil).Once()

// ‚úÖ Validar n√∫mero de llamadas
mockRepo.AssertNumberOfCalls(t, "UpdateStatus", 1)

// ‚úÖ Validar que NO se llam√≥ un m√©todo
mockRepo.AssertNotCalled(t, "Delete")
```

## Estrategias de Testing

### Tipos de Tests
- **Unit Tests**: Para cada funci√≥n/m√©todo p√∫blico
- **Integration Tests**: Para flujos completos entre componentes
- **Repository Tests**: Para validar integraci√≥n con APIs externas

### Coverage Goals
- **M√≠nimo**: 80% de coverage
- **Objetivo**: 90%+ para c√≥digo cr√≠tico
- **Foco**: Priorizar paths principales y casos de error

### Test Data Management

#### Para Tests Unitarios
```go
// ‚úÖ Usar TimeManagerMock en tests
func setupTestData() *TestInput {
    mockTimeManager := new(timeManager.TimeManagerMock)
    testDate := time.Date(2024, 1, 15, 0, 0, 0, 0, time.UTC)
    
    return &TestInput{
        UserID:    123,
        Products:  []string{"consumer_loan", "personal_loan"},
        CreatedAt: testDate,
    }
}
```

## Testing con Sandbox/Beta

### Loki para Mocking
Para pruebas en beta, usar Loki client para mockear dependencias:
- Seguir documentaci√≥n: `github.com/melisource/fury_loki-client`
- Crear casos de prueba documentados
- Validar comportamiento en environment real

### Limitaciones Locales
- **Rules Engine**: Solo responde con `low` en desarrollo local
- **Validaci√≥n completa**: Realizar pruebas en entorno beta
- **Credit Level**: Testing real solo en beta

## Checklist de Testing

- [ ] ¬øTests unitarios para nuevas funciones p√∫blicas?
- [ ] ¬øTests de error cases y edge cases?
- [ ] ¬øMocks siguen las convenciones de naming?
- [ ] ¬øCoverage m√≠nimo del 80%?
- [ ] ¬øTests de integraci√≥n para flujos cr√≠ticos?
- [ ] ¬øDocumentaci√≥n de casos de prueba para beta? 
- [ ] ¬øSon los tests unitarios lo mas at√≥micos posibles?
