---
alwaysApply: true
---

# üíª Est√°ndares de C√≥digo Go

## Herramientas Obligatorias

### Linters
```bash
# Linter principal
golangci-lint run

# Linter con configuraci√≥n custom
golangci-lint run -c .code_quality/.golangci.yml

# Pre-commit
pre-commit run --all-files
```

### Formateo
```bash
# Herramientas est√°ndar
gofmt
go vet
```

## Buenas Pr√°cticas de C√≥digo

### Manejo de Errores
- **Siempre expl√≠cito**: Nunca ignorar errores
- **Errores tipados**: Usar constructores espec√≠ficos del package `internal/core/errors`
- **No usar fmt.Errorf**: Preferir errores tipados sobre error wrapping gen√©rico
- **Validaci√≥n temprana**: Validar par√°metros al inicio de funciones

```go
// ‚úÖ Ejemplo correcto - Usar errores tipados
func (r *Repository) Search(ctx context.Context, userID int64, products []string) ([]entities.SearchResults, error) {
    if userID <= 0 {
        return nil, errors.NewBadRequest("invalid userID")
    }
    
    results, err := r.searchCreditLines(ctx, userID, products)
    if err != nil {
        return nil, errors.NewInternalServerError("failed to search credit lines")
    }
    
    return results, nil
}

// ‚úÖ Tipos de errores disponibles
func ExampleErrorTypes() {
    // Errores de cliente
    errors.NewBadRequest("invalid input")
    errors.NewResourceNotFound("user not found")
    errors.NewUnauthorizedRequest("authentication required")
    
    // Errores de servidor
    errors.NewInternalServerError("database connection failed")
    errors.NewTooManyRequests("rate limit exceeded")
    
    // Errores espec√≠ficos del dominio
    errors.NewResourceParsingError("invalid date format")
    errors.NewSkippableError("optional service unavailable")
}
```

### Context Management
- **Usar context.Context**: Para todas las operaciones as√≠ncronas
- **Propagaci√≥n**: Pasar context a trav√©s de todas las capas
- **Timeouts**: Configurar timeouts apropiados

```go
// ‚úÖ Ejemplo correcto
func (s *Service) ProcessRequest(ctx context.Context, req *Request) (*Response, error) {
    // Usar context en todas las llamadas downstream
    data, err := s.repository.GetData(ctx, req.ID)
    if err != nil {
        return nil, errors.NewInternalServerError("failed to get data")
    }
    
    return s.processData(ctx, data)
}
```

### Interfaces
- **Peque√±as y espec√≠ficas**: Preferir interfaces peque√±as
- **Definir donde se usan**: No en packages globales
- **Composici√≥n**: Combinar interfaces peque√±as para crear mayores

```go
// ‚úÖ Ejemplo correcto
type CreditLine interface {
    Search(ctx context.Context, userID int64, statuses []string, products []string) ([]entities.SearchResults, error)
}
```

### Convenciones de Naming

#### Principios Generales
- **Descriptivos**: Nombres que expliquen el prop√≥sito
- **Consistentes**: Seguir convenciones de Go
- **Evitar abreviaciones**: Usar nombres completos y claros
- **Acr√≥nimos**: En may√∫sculas (ID, HTTP, JSON)

#### Variables, Constantes y Estructuras
- **camelCase**: Para nombres de variables, constantes, campos de struct y funciones
- **PascalCase**: Para tipos exportados (structs, interfaces)

```go
// ‚úÖ Correcto
type UserID int64
type HTTPClient interface{}
type APIResponse struct{}

var creditScoringEngine string
const maxRetryAttempts = 3

type CreditScoreRequest struct {
    UserID       int64
    SiteID       string
    ScoreValue   float64
}

// ‚ùå Incorrecto  
type UserId int64
type HttpClient interface{}
type ApiResponse struct{}

var credit_scoring_engine string  // ‚ùå snake_case en variables
const MAX_RETRY_ATTEMPTS = 3      // ‚ùå UPPER_CASE en constantes
```

#### Directorios y Packages
- **snake_case**: Para nombres de directorios y packages
- **camelCase**: Para import aliases

```go
// ‚úÖ Correcto - Directorios en snake_case
internal/core/usecases/credit_scoring_reports/
internal/infrastructure/adapters/time_manager/

// ‚úÖ Correcto - Import aliases en camelCase
import (
    creditScoringReports "github.com/project/internal/core/usecases/credit_scoring_reports"
    creditScoringEntity "github.com/project/internal/core/domain/entities/credit_scoring"
    timeManager "github.com/project/internal/infrastructure/adapters/time_manager"
)

// ‚ùå Incorrecto - Aliases inconsistentes
import (
    credit_scoring_reports "..."  // ‚ùå snake_case en alias
    creditscoring "..."           // ‚ùå sin separaci√≥n
    tm "..."                      // ‚ùå abreviaci√≥n no clara
)
```

#### Import Aliases Espec√≠ficos
- **Directorio credit_scoring**: Siempre usar `creditScoringEntity`
- **Directorio credit_scoring_reports**: Siempre usar `creditScoringReports` 
- **Contratos**: Sufijo `Contract` (ej: `requestContract`, `responseContract`)
- **Entidades**: Sufijo `Entity` cuando sea necesario evitar colisiones

```go
// ‚úÖ Patr√≥n est√°ndar del proyecto
import (
    requestContract "github.com/project/internal/core/domain/contracts/credit_scoring_reports/request"
    responseContract "github.com/project/internal/core/domain/contracts/credit_scoring_reports/response"
    creditScoringEntity "github.com/project/internal/core/domain/entities/credit_scoring"
    timeManager "github.com/project/internal/infrastructure/adapters/time_manager"
)
```

### Comentarios en el C√≥digo
- **NO comentar c√≥digo**: El c√≥digo debe ser autoexplicativo
- **Nombres descriptivos**: Usar nombres que expliquen el prop√≥sito
- **Funciones peque√±as**: Dividir en funciones m√°s peque√±as y descriptivas

```go
// ‚ùå MAL - Comentar funcionalidad obvia
// Esta funci√≥n suma dos n√∫meros
func sum(a, b int) int {
    return a + b
}

// ‚úÖ BIEN - Nombre descriptivo sin comentario
func calculateTotalWithTax(amount, taxRate float64) float64 {
    return amount * (1 + taxRate)
}
```

## Estructura de Funciones

### Orden de Validaci√≥n
1. **Validaci√≥n de par√°metros**
2. **L√≥gica principal**
3. **Manejo de respuestas**

```go
// ‚úÖ Estructura recomendada
func ProcessData(ctx context.Context, input *Input) (*Output, error) {
    // 1. Validaciones
    if input == nil {
        return nil, errors.NewBadRequest("input cannot be nil")
    }
    if input.UserID <= 0 {
        return nil, errors.NewBadRequest("invalid user ID")
    }
    
    // 2. L√≥gica principal
    result, err := processBusinessLogic(ctx, input)
    if err != nil {
        return nil, errors.NewInternalServerError("business logic failed")
    }
    
    // 3. Preparar respuesta
    return &Output{
        Data: result,
        Timestamp: time.Now(),
    }, nil
}
```

## Logging Estructurado

### Formato Est√°ndar
```go
// ‚úÖ Usar logs estructurados
logger.Error(ctx, err, "Error getting data from API", 
    logs.Tags{
        "api_name": apiName, 
        "user_id": userID,
        "operation": "search",
    })

// ‚úÖ Logs de informaci√≥n
logger.Info(ctx, "Processing request", 
    logs.Tags{
        "user_id": userID,
        "products": strings.Join(products, ","),
    })
```

## Manejo de Fechas

### TimeManager Obligatorio
- **Producci√≥n**: Usar SIEMPRE `TimeManager` para todas las operaciones de fecha
- **Tests**: Usar `TimeManagerMock` para mockear comportamiento

```go
// ‚úÖ Correcto - Inyecci√≥n de dependencia con TimeManager
type MyService struct {
    TimeManager timeManager.TimeManager
}

// ‚úÖ Correcto - Uso en c√≥digo de producci√≥n
func (s *MyService) FormatDate(date time.Time) string {
    return s.TimeManager.FormatToISO8601(date)
}

// ‚úÖ Correcto - Parsing de fechas
func (s *MyService) ParseDate(dateString string) (time.Time, error) {
    return s.TimeManager.StringToUTC(dateString)
}

// ‚úÖ Correcto - Mock en tests
func TestService(t *testing.T) {
    mockTimeManager := new(timeManager.TimeManagerMock)
    mockTimeManager.On("Now").Return(time.Date(2024, 1, 15, 0, 0, 0, 0, time.UTC))
    
    service := &MyService{TimeManager: mockTimeManager}
    // ... test logic
}
```

### Funciones Principales del TimeManager
- `Now()` - Tiempo actual en UTC
- `FormatToISO8601(date)` - Formato ISO8601 Zulu
- `FormatToOffset(date)` - Formato con offset
- `StringToUTC(dateString)` - Parse string a UTC
- `StringYearMonthDayToUTC(date)` - Parse formato YYYY-MM-DD
- `FirstDayOfNextMonth(date, siteID)` - Primer d√≠a del siguiente mes
- `GetDateWithoutTime(date, siteID)` - Fecha sin tiempo por site

### Inicializaci√≥n del TimeManager
```go
// ‚úÖ Correcto - Inicializaci√≥n en contenedor de dependencias
timeManagerImpl := timeManager.TimeManagerImpl{}

// ‚úÖ Correcto - Inyecci√≥n en servicios
service := &MyService{
    TimeManager: timeManagerImpl,
}

// ‚úÖ Correcto - En tests usar mock
mockTimeManager := new(timeManager.TimeManagerMock)
service := &MyService{
    TimeManager: mockTimeManager,
}
```

### ‚ùå Pr√°cticas Obsoletas
**NO usar m√°s:**
- ~~`utils.ParseDate()`~~ - Package utils eliminado
- ~~`dates.NewDateAdapter()`~~ - Package dates deprecado  
- ~~`dates.StringYearMonthDayToUTC()`~~ - Migrado a TimeManager
